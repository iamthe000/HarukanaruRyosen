<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>遥かなる稜線</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #aaccff; }
        #instructions {
            position: absolute;
            top: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0,0,0,0.3);
            color: white;
            pointer-events: none;
            text-align: center;
            user-select: none;
            backdrop-filter: blur(8px);
        }
        #blocker {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(20, 10, 40, 0.2);
            z-index: 99;
        }
        h1 { margin: 0; font-size: 50px; text-shadow: 0 0 20px rgba(200,220,255,0.8); font-weight: lighter; letter-spacing: 4px; }
        p { font-size: 18px; line-height: 1.6; text-shadow: 0 0 5px rgba(0,0,50,0.5); }
        .key { font-weight: bold; color: #fff; border: 1px solid #fff; padding: 2px 6px; border-radius: 4px; background: rgba(255,255,255,0.2); }
        #vignette {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, rgba(50,20,80,0.3) 100%);
            pointer-events: none;
            z-index: 90;
        }
        #speed-lines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: transparent;
            opacity: 0;
            pointer-events: none;
            z-index: 91;
            box-shadow: inset 0 0 100px rgba(200,240,255,0.3);
            transition: opacity 0.1s;
        }
        
        /* --- Mobile Controls Styles --- */
        #mobile-controls { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            display: none; 
            touch-action: none; 
        }
        .joystick-area { 
            position: absolute; 
            bottom: 30px; 
            left: 30px; 
            width: 150px; 
            height: 150px; 
            background: rgba(255,255,255,0.2); 
            border-radius: 50%; 
        }
        #joystick-thumb { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            width: 50px; 
            height: 50px; 
            background: rgba(255,255,255,0.5); 
            border-radius: 50%; 
            transform: translate(-50%, -50%); 
        }
        #jump-button { 
            position: absolute; 
            bottom: 40px; 
            right: 40px; 
            width: 80px; 
            height: 80px; 
            background: rgba(255,255,255,0.3); 
            border-radius: 50%; 
            display:flex; 
            justify-content:center; 
            align-items:center; 
            font-size: 14px; 
            color: white; 
            border: 2px solid white; 
        }
        /* カメラ操作エリアを画面全体に設定し、ジョイスティックより下に配置 */
        #camera-controls {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 9; 
        }
        .joystick-area, #jump-button {
            z-index: 10; 
        }

    </style>
</head>
<body>
    <div id="vignette"></div>
    <div id="speed-lines"></div>
    <div id="mobile-controls">
        <div id="camera-controls"></div> 
        <div class="joystick-area">
            <div id="joystick-thumb"></div>
        </div>
        <div id="jump-button">JUMP</div>
    </div>
    <div id="blocker">
        <div id="instructions">
            <h1>遥かなる稜線</h1>
            <p>
                クリックまたはタッチして旅を始める<br><br>
                移動: <span class="key">W, A, S, D</span><br>
                ダッシュ: <span class="key">Shift</span><br>
                ジャンプ: <span class="key">Space</span><br>
                <br>
                <span style="font-size: 14px; color: #ddeeff;">果てしなく続く平原と山脈</span>
            </p>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';
        import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
        import { Sky } from 'three/addons/objects/Sky.js';

        // --- グローバル変数 ---
        let camera, scene, renderer, controls;
        let playerBody; 
        let blocker;
        let sky, sun;
        
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let isSprinting = false;
        let canJump = false;

        let prevTime = performance.now();

        // --- アクション・カメラ設定 ---
        let walkCycle = 0;
        const camOffset = { x: 0, y: 0 }; 
        
        let isRolling = false;
        let rollStartTime = 0;
        const rollDuration = 0.65;
        const rollThreshold = 280;
        let targetRollAngle = 0;
        
        const baseFov = 100;
        const standingEyeHeight = 10;
        
        // --- 地形設定 ---
        const chunkSize = 400; 
        const chunkRes = 40; 
        const renderDistance = 3; 
        const waterLevel = 22; 
        const chunks = {};
        const perlin = new ImprovedNoise();
        const seed = Math.random() * 100;

        // --- 盆地生成パラメータ ---
        const BASIN_FLAT_RADIUS = 550;   
        const BASIN_WALL_START = 550;    
        const BASIN_PEAK_DIST = 1100;    
        const BASIN_WALL_END = 1600;     
        const WALL_HEIGHT = 500;         
        
        let treeGeometry, treeMaterial;
        let grassGeometry, grassMaterial;
        let waterGeometry, waterMaterial;

        const speedLines = document.getElementById('speed-lines');

        const skyUniforms = {
            turbidity: 8,
            rayleigh: 2,
            mieCoefficient: 0.005,
            mieDirectionalG: 0.8,
            elevation: 25,
            azimuth: 180,
            exposure: 0.6
        };

        const FOG_COLOR = 0xcce0ff; 

        let isMobile = false;
        let activeTouch = { joystick: null, camera: null }; 

        // --- Gamepad State ---
        let gamepadConnected = false;
        const keyState = {}; // Tracks keyboard key presses

        // 視点感度調整用の定数
        const SENSITIVITY_MULTIPLIER = 20; 

        init();
        animate();

        window.addEventListener("gamepadconnected", (event) => {
            console.log("Gamepad connected:", event.gamepad.id);
            gamepadConnected = true;
        });

        window.addEventListener("gamepaddisconnected", (event) => {
            console.log("Gamepad disconnected:", event.gamepad.id);
            gamepadConnected = false;
        });

        function init() {
            blocker = document.getElementById('blocker');
            const instructions = document.getElementById('instructions');
            const mobileControls = document.getElementById('mobile-controls');

            // ユーザーエージェントベースのモバイル判定
            isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || ('ontouchstart' in window);

            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(FOG_COLOR, 0.0010); 
            scene.background = new THREE.Color(FOG_COLOR);

            camera = new THREE.PerspectiveCamera(baseFov, window.innerWidth / window.innerHeight, 0.1, 8000);

            playerBody = new THREE.Object3D();
            playerBody.position.set(0, 100, 50); 
            playerBody.add(camera); 
            scene.add(playerBody);

            // --- Sky ---
            sky = new Sky();
            sky.scale.setScalar(450000);
            scene.add(sky);

            sun = new THREE.Vector3();
            
            const effectController = skyUniforms;

            const uniforms = sky.material.uniforms;
            uniforms[ 'turbidity' ].value = effectController.turbidity;
            uniforms[ 'rayleigh' ].value = effectController.rayleigh;
            uniforms[ 'mieCoefficient' ].value = effectController.mieCoefficient;
            uniforms[ 'mieDirectionalG' ].value = effectController.mieDirectionalG;

            const phi = THREE.MathUtils.degToRad( 90 - effectController.elevation );
            const theta = THREE.MathUtils.degToRad( effectController.azimuth );
            sun.setFromSphericalCoords( 1, phi, theta );
            uniforms[ 'sunPosition' ].value.copy( sun );

            // --- Lighting ---
            const dirLight = new THREE.DirectionalLight(0xfffaed, 1.5); 
            dirLight.position.set(sun.x * 1000, sun.y * 1000, sun.z * 1000);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 4096;
            dirLight.shadow.mapSize.height = 4096;
            const d = 2500; 
            dirLight.shadow.camera.left = -d;
            dirLight.shadow.camera.right = d;
            dirLight.shadow.camera.top = d;
            dirLight.shadow.camera.bottom = -d;
            dirLight.shadow.camera.far = 6000;
            dirLight.shadow.bias = -0.0001;
            dirLight.shadow.radius = 2; 
            scene.add(dirLight);
            
            const hemiLight = new THREE.HemisphereLight(0xffeeb1, 0x6655aa, 0.85); 
            hemiLight.position.set(0, 500, 0);
            scene.add(hemiLight);

            // --- Controls ---
            controls = new PointerLockControls(playerBody, document.body);
            controls.minPolarAngle = 0.05; 
            controls.maxPolarAngle = Math.PI - 0.05;

            function startExperience() {
                instructions.style.display = 'none';
                blocker.style.display = 'none';
                if (isMobile) {
                    mobileControls.style.display = 'block';
                } else {
                    controls.lock();
                }
            }

            blocker.addEventListener('click', startExperience);
            blocker.addEventListener('touchstart', startExperience);
            
            controls.addEventListener('unlock', () => {
                blocker.style.display = 'block';
                instructions.style.display = 'flex';
                 if (isMobile) mobileControls.style.display = 'none';
            });

            const onKeyDown = (e) => {
                if (isMobile) return;
                keyState[e.code] = true;
            };

            const onKeyUp = (e) => {
                if (isMobile) return;
                keyState[e.code] = false;
            };
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            if (isMobile) {
                setupMobileControls();
            }

            prepareAssets();

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            renderer.toneMapping = THREE.CineonToneMapping; 
            renderer.toneMappingExposure = 0.9; 
            
            document.body.appendChild(renderer.domElement);
            window.addEventListener('resize', onWindowResize);
        }

        function setupMobileControls() {
            const joystickThumb = document.getElementById('joystick-thumb');
            const joystickArea = joystickThumb.parentElement;
            const jumpButton = document.getElementById('jump-button');
            const cameraControls = document.getElementById('camera-controls');
            const controlsRoot = document.getElementById('mobile-controls'); 

            let joystickRect = joystickArea.getBoundingClientRect();
            
            // タッチ開始時の処理
            controlsRoot.addEventListener('touchstart', (e) => {
                e.preventDefault(); 
                
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];

                    // ジョイスティックエリア判定
                    if (joystickArea.contains(touch.target)) {
                        
                        if (activeTouch.joystick === null) {
                            activeTouch.joystick = touch.identifier;
                        }
                    } 
                    // ジャンプボタンエリア判定
                    else if (jumpButton.contains(touch.target)) {
                        if (canJump && !isRolling) {
                            velocity.y += 160;
                            canJump = false;
                        }
                    }
                    // カメラ操作エリア判定
                    else if (activeTouch.camera === null) {
                        activeTouch.camera = touch.identifier;
                        cameraControls.dataset.prevX = touch.clientX;
                        cameraControls.dataset.prevY = touch.clientY;
                    }
                }
            }, { passive: false });

            // タッチ移動中の処理
            controlsRoot.addEventListener('touchmove', (e) => {
                e.preventDefault();
                
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    const x = touch.clientX;
                    const y = touch.clientY;

                    // --- プレイヤー移動 (ジョイスティック) ---
                    if (touch.identifier === activeTouch.joystick) {
                        const center = { x: joystickRect.left + joystickRect.width / 2, y: joystickRect.top + joystickRect.height / 2 };
                        
                        let dx = x - center.x;
                        let dy = y - center.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        
                        const maxDist = joystickRect.width / 2;
                        
                        if (dist > maxDist) {
                            dx = (dx / dist) * maxDist;
                            dy = (dy / dist) * maxDist;
                        }
                        
                        joystickThumb.style.transform = `translate(-50%, -50%) translate(${dx}px, ${dy}px)`;

                        const angle = Math.atan2(dy, dx);
                        const strength = Math.min(dist / (maxDist * 0.8), 1.0); 
                        
                        const moveThreshold = 0.3; 
                        
                        // 移動方向のフラグ設定: 角度はスクリーン座標のY軸が下向きで正
                        moveForward = strength > moveThreshold && (angle > -2.356 && angle < -0.785); // 上方向
                        moveBackward = strength > moveThreshold && (angle > 0.785 && angle < 2.356);  // 下方向
                        moveLeft = strength > moveThreshold && (angle <= -2.356 || angle > 2.356);    // 左方向
                        moveRight = strength > moveThreshold && (angle > -0.785 && angle < 0.785);    // 右方向

                        isSprinting = moveForward && strength > 0.8;
                    } 
                    
                    // --- 視点移動 (カメラ) ---
                    else if (touch.identifier === activeTouch.camera) {
                        const prevX = parseFloat(cameraControls.dataset.prevX);
                        const prevY = parseFloat(cameraControls.dataset.prevY);

                        // 感度調整用の乗数 (0.005 * 20 = 0.1 の実効感度)
                        const sensitivity = 0.005; 

                        const dx = (x - prevX) * sensitivity;
                        const dy = (y - prevY) * sensitivity;

                        // 横方向の回転（Y軸）はプレイヤーボディを回転させる
                        playerBody.rotation.y -= dx * SENSITIVITY_MULTIPLIER; 

                        // 縦方向の回転（X軸）はカメラを回転させる
                        const cam = camera;
                        cam.rotation.x -= dy * SENSITIVITY_MULTIPLIER; 
                        
                        // 上下制限
                        cam.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cam.rotation.x));

                        cameraControls.dataset.prevX = x;
                        cameraControls.dataset.prevY = y;
                    }
                }
            }, { passive: false });
            
            // タッチ終了時の処理
            controlsRoot.addEventListener('touchend', (e) => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    
                    // ジョイスティック終了
                    if (touch.identifier === activeTouch.joystick) {
                        activeTouch.joystick = null;
                        joystickThumb.style.transform = `translate(-50%, -50%)`;
                        moveForward = moveBackward = moveLeft = moveRight = false;
                        isSprinting = false;
                    }
                    
                    // カメラ操作終了
                    else if (touch.identifier === activeTouch.camera) {
                        activeTouch.camera = null;
                        delete cameraControls.dataset.prevX;
                        delete cameraControls.dataset.prevY;
                    }
                }
            });

            // ウィンドウリサイズ時のジョイスティックエリア再計算
            window.addEventListener('resize', () => {
                joystickRect = joystickArea.getBoundingClientRect();
            });
        }

        function prepareAssets() {
            const trunkGeo = new THREE.CylinderGeometry(1, 2.5, 12, 6);
            trunkGeo.translate(0, 6, 0);
            const leavesGeo = new THREE.ConeGeometry(7, 18, 6);
            leavesGeo.translate(0, 20, 0);
            const leavesGeo2 = new THREE.ConeGeometry(5, 14, 6);
            leavesGeo2.translate(0, 28, 0);
            
            treeGeometry = BufferGeometryUtils.mergeGeometries([trunkGeo, leavesGeo, leavesGeo2]);
            treeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x44bb66, 
                flatShading: true, 
                roughness: 0.8,
                emissive: 0x002211,
                emissiveIntensity: 0.2
            });

            grassGeometry = new THREE.PlaneGeometry(4, 4);
            grassGeometry.translate(0, 2, 0);
            grassMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x99dd55, 
                side: THREE.DoubleSide, 
                alphaTest: 0.5,
                emissive: 0x113300,
                emissiveIntensity: 0.1
            });

            waterGeometry = new THREE.PlaneGeometry(chunkSize, chunkSize);
            waterGeometry.rotateX(-Math.PI / 2);
            waterMaterial = new THREE.MeshStandardMaterial({
                color: 0x22eeff,
                transparent: true,
                opacity: 0.7, 
                roughness: 0.1,
                metalness: 0.3,
                emissive: 0x006688,
                emissiveIntensity: 0.4
            });
        }

        function getNoiseHeight(x, z) {
            const dist = Math.sqrt(x * x + z * z);
            
            let baseHeight = 0;
            baseHeight += Math.abs(perlin.noise(x * 0.003 + seed, z * 0.003 + seed, seed)) * 30;

            let finalHeight = baseHeight;

            if (dist < BASIN_WALL_END) {
                if (dist < BASIN_FLAT_RADIUS) {
                    let h = 32 + perlin.noise(x * 0.008, z * 0.008, seed) * 10;
                    const riverNoise = perlin.noise(x * 0.004 + seed, z * 0.004 + seed, seed + 10);
                    if (riverNoise < -0.15) {
                        const depth = (-0.15 - riverNoise) * 60; 
                        h -= depth; 
                    }
                    if (dist < 180) {
                        const lakeDepth = (1.0 - (dist / 180)) * 25;
                        h -= lakeDepth;
                    }
                    finalHeight = h;
                } else {
                    let wallFactor = 0;
                    if (dist < BASIN_PEAK_DIST) {
                        const t = (dist - BASIN_WALL_START) / (BASIN_PEAK_DIST - BASIN_WALL_START);
                        wallFactor = t * t * (3 - 2 * t);
                    } else {
                        const t = (dist - BASIN_PEAK_DIST) / (BASIN_WALL_END - BASIN_PEAK_DIST);
                        wallFactor = 1 - (t * t * (3 - 2 * t)); 
                    }
                    const mountainNoise = Math.abs(perlin.noise(x * 0.02, z * 0.02, seed + 50)) * 180;
                    const wallHeight = (WALL_HEIGHT + mountainNoise) * wallFactor;
                    finalHeight = baseHeight + wallHeight;
                    if (dist < BASIN_PEAK_DIST && finalHeight < 30) finalHeight = 30; 
                }
            } else {
                let blend = (dist - BASIN_WALL_END) / 1500;
                if (blend > 1.0) blend = 1.0;
                blend = blend * blend * (3 - 2 * blend); 

                const biomeNoise = perlin.noise(x * 0.0004, z * 0.0004, seed + 100);
                const mountainMix = THREE.MathUtils.smoothstep(biomeNoise, 0.2, 0.6);

                const largeMtn = Math.abs(perlin.noise(x * 0.0015, z * 0.0015, seed + 10)) * 1200;
                const detailMtn = perlin.noise(x * 0.01, z * 0.01, seed + 20) * 150;
                const mountainShape = largeMtn + detailMtn;

                const hillBase = perlin.noise(x * 0.001, z * 0.001, seed + 30) * 60; 
                const hillDetail = perlin.noise(x * 0.005, z * 0.005, seed + 40) * 20;
                
                const riverCarver = Math.abs(perlin.noise(x * 0.0005 + 500, z * 0.0005 + 500, seed + 60));
                let riverDepth = 0;
                if (riverCarver < 0.1) {
                    riverDepth = (0.1 - riverCarver) * 800; 
                }

                const plainShape = 35 + hillBase + hillDetail - riverDepth;

                let outerTerrain = (mountainShape * mountainMix) + (plainShape * (1 - mountainMix));

                finalHeight = baseHeight + (outerTerrain * blend);
            }
            
            return finalHeight; 
        }

        function getSlope(x, z) {
            const step = 2;
            const h = getNoiseHeight(x, z);
            const hx = getNoiseHeight(x + step, z);
            const hz = getNoiseHeight(x, z + step);
            const dx = (hx - h) / step;
            const dz = (hz - h) / step;
            return Math.sqrt(dx*dx + dz*dz);
        }

        function updateChunks() {
            const playerPos = playerBody.position;
            const cx = Math.floor(playerPos.x / chunkSize);
            const cz = Math.floor(playerPos.z / chunkSize);
            const activeKeys = new Set();

            for (let x = -renderDistance; x <= renderDistance; x++) {
                for (let z = -renderDistance; z <= renderDistance; z++) {
                    const key = `${cx + x},${cz + z}`;
                    activeKeys.add(key);
                    if (!chunks[key]) createChunk(cx + x, cz + z);
                }
            }
            for (const key in chunks) {
                if (!activeKeys.has(key)) {
                    scene.remove(chunks[key]);
                    delete chunks[key];
                }
            }
        }

        function createChunk(cx, cz) {
            const group = new THREE.Group();
            
            const geometry = new THREE.PlaneGeometry(chunkSize, chunkSize, chunkRes, chunkRes);
            geometry.rotateX(-Math.PI / 2);
            const posAttr = geometry.attributes.position;
            const colors = [];

            for (let i = 0; i < posAttr.count; i++) {
                const x = posAttr.getX(i) + (cx * chunkSize);
                const z = posAttr.getZ(i) + (cz * chunkSize);
                const y = getNoiseHeight(x, z);
                posAttr.setY(i, y);

                if (y < waterLevel + 3) {
                    colors.push(0.85, 0.8, 0.65);
                } else if (y < 120) {
                    const n = perlin.noise(x*0.02, z*0.02, seed);
                    const r = 0.35 + n * 0.1;
                    const g = 0.7 + n * 0.15;
                    const b = 0.3 + n * 0.1;
                    colors.push(r, g, b); 
                } else if (y < 400) { 
                    colors.push(0.6, 0.55, 0.5); 
                } else { 
                    colors.push(0.96, 0.98, 1.0); 
                }
            }
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.computeVertexNormals();
            
            const terrainMesh = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({ 
                vertexColors: true, 
                flatShading: true, 
                roughness: 1.0 
            }));
            terrainMesh.position.set(cx * chunkSize, 0, cz * chunkSize);
            terrainMesh.receiveShadow = true;
            group.add(terrainMesh);

            const waterMesh = new THREE.Mesh(waterGeometry, waterMaterial);
            waterMesh.position.set(cx * chunkSize, waterLevel, cz * chunkSize);
            group.add(waterMesh);

            const treeCount = 60; 
            const treeMesh = new THREE.InstancedMesh(treeGeometry, treeMaterial, treeCount);
            treeMesh.castShadow = true;
            treeMesh.receiveShadow = true;
            
            const dummy = new THREE.Object3D();
            let tIdx = 0;
            
            for (let i = 0; i < treeCount; i++) {
                const rx = (Math.random() - 0.5) * chunkSize;
                const rz = (Math.random() - 0.5) * chunkSize;
                const wx = rx + (cx * chunkSize);
                const wz = rz + (cz * chunkSize);
                
                const h = getNoiseHeight(wx, wz);
                const slope = getSlope(wx, wz);
                
                if (h > waterLevel + 4 && slope < 1.2) {
                    if (h < 250) {
                        if (Math.random() > 0.4) {
                            dummy.position.set(rx, h, rz);
                            const s = 0.8 + Math.random() * 1.0; 
                            dummy.scale.set(s, s, s);
                            dummy.rotation.y = Math.random() * Math.PI * 2;
                            dummy.updateMatrix();
                            treeMesh.setMatrixAt(tIdx++, dummy.matrix);
                        }
                    }
                }
            }
            treeMesh.count = tIdx; 
            treeMesh.position.set(cx * chunkSize, 0, cz * chunkSize);
            group.add(treeMesh);

            const grassCount = 1200;
            const grassMesh = new THREE.InstancedMesh(grassGeometry, grassMaterial, grassCount);
            let gIdx = 0;
            for (let i = 0; i < grassCount; i++) {
                const rx = (Math.random() - 0.5) * chunkSize;
                const rz = (Math.random() - 0.5) * chunkSize;
                const wx = rx + (cx * chunkSize);
                const wz = rz + (cz * chunkSize);
                const h = getNoiseHeight(wx, wz);
                const slope = getSlope(wx, wz);

                if (h > waterLevel + 2 && h < 250 && slope < 0.8) {
                    dummy.position.set(rx, h, rz);
                    dummy.scale.set(1, 1, 1);
                    dummy.rotation.set(0, Math.random() * Math.PI, 0);
                    dummy.updateMatrix();
                    grassMesh.setMatrixAt(gIdx++, dummy.matrix);
                }
            }
            grassMesh.count = gIdx;
            grassMesh.position.set(cx * chunkSize, 0, cz * chunkSize);
            group.add(grassMesh);

            scene.add(group);
            chunks[`${cx},${cz}`] = group;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function easeOutCubic(x) {
            return 1 - Math.pow(1 - x, 3);
        }

        function handleGamepadInput() {
            if (!gamepadConnected) return; // No gamepad, nothing to do.
        
            const gamepad = navigator.getGamepads()[0];
            if (!gamepad) return;
        
            // Deadzone for joysticks
            const deadzone = 0.15;
        
            // --- Left Stick for Movement (Overrides Keyboard) ---
            const leftStickX = gamepad.axes[0];
            const leftStickY = gamepad.axes[1];
        
            if (Math.abs(leftStickX) > deadzone || Math.abs(leftStickY) > deadzone) {
                moveForward = leftStickY < -deadzone;
                moveBackward = leftStickY > deadzone;
                moveLeft = leftStickX < -deadzone;
                moveRight = leftStickX > deadzone;
            }
        
            // --- Right Stick for Camera ---
            const rightStickX = gamepad.axes[2];
            const rightStickY = gamepad.axes[3];
            const sensitivity = 0.04;
        
            if (Math.abs(rightStickX) > deadzone) {
                playerBody.rotation.y -= rightStickX * sensitivity * SENSITIVITY_MULTIPLIER;
            }
            if (Math.abs(rightStickY) > deadzone) {
                const cam = camera;
                cam.rotation.x -= rightStickY * sensitivity * SENSITIVITY_MULTIPLIER;
                cam.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cam.rotation.x));
            }
        
            // --- Buttons ---
            // A button (button 0) for Jump
            if (gamepad.buttons[0].pressed) {
                if (canJump && !isRolling) {
                    velocity.y += 160;
                    canJump = false;
                }
            }
            
            // Left stick press (button 10) for Sprint (Additive to Keyboard)
            if (gamepad.buttons[10].pressed) {
                isSprinting = true;
            }
        }

        function handleKeyboardInput() {
            // Set base movement from keyboard. Gamepad will override if active.
            moveForward = keyState['KeyW'] || false;
            moveBackward = keyState['KeyS'] || false;
            moveLeft = keyState['KeyA'] || false;
            moveRight = keyState['KeyD'] || false;
        
            isSprinting = keyState['ShiftLeft'] || false;
        
            if (keyState['Space']) {
                if (canJump && !isRolling) {
                    velocity.y += 160;
                    canJump = false;
                }
            }
        }


        // --- アニメーションループ ---
        function animate() {
            requestAnimationFrame(animate);

            // First, set state from keyboard
            handleKeyboardInput();
            // Then, override with gamepad if it's active
            handleGamepadInput();

            const time = performance.now();
            const delta = Math.min((time - prevTime) / 1000, 0.1); 
            prevTime = time;

            if (sky) {
                const uniforms = sky.material.uniforms;
                const tempVec = new THREE.Vector3().copy(uniforms['sunPosition'].value).normalize();
                const dirLight = scene.children.find(c => c.isDirectionalLight);
                if (dirLight) {
                    dirLight.position.copy(tempVec).multiplyScalar(10000);
                }
            }

            const gameActive = controls.isLocked || (isMobile && blocker.style.display === 'none');

            if (gameActive) {
                updateChunks();

                const body = playerBody;

                const dampingX = canJump ? 8.0 : 1.0; 
                const dampingZ = canJump ? 8.0 : 1.0;
                
                velocity.x -= velocity.x * dampingX * delta;
                velocity.z -= velocity.z * dampingZ * delta;
                velocity.y -= 9.8 * 60.0 * delta; 

                // ジョイスティックのフラグから移動方向を決定
                direction.z = Number(moveForward) - Number(moveBackward); // +1: Forward, -1: Backward
                direction.x = Number(moveRight) - Number(moveLeft);      // +1: Right, -1: Left
                direction.normalize();

                const speedBase = isSprinting ? 1200.0 : 600.0;
                
                if (!isRolling) {
                    // ジョイスティック入力に応じてローカルのX/Z速度を更新
                    if (moveForward || moveBackward) velocity.z -= direction.z * speedBase * delta;
                    if (moveLeft || moveRight) velocity.x -= direction.x * speedBase * delta;
                }

                if (isMobile) {
                    // モバイルデバイスの場合、プレイヤーのローカル座標系で直接移動させます
                    playerBody.translateX(-velocity.x * delta);
                    playerBody.translateZ(-velocity.z * delta);
                } else {
                    // PC時の移動計算
                    controls.moveRight(-velocity.x * delta);
                    controls.moveForward(-velocity.z * delta);
                }
                body.position.y += (velocity.y * delta); 

                const groundHeight = getNoiseHeight(body.position.x, body.position.z);
                
                if (body.position.y < groundHeight + standingEyeHeight) {
                    if (!canJump) { 
                        const fallSpeed = Math.abs(velocity.y);
                        if (fallSpeed > rollThreshold) {
                            isRolling = true;
                            rollStartTime = time;
                            // ロール時の速度計算：カメラの現在の向きを前方とする
                            const forwardDir = new THREE.Vector3();
                            camera.getWorldDirection(forwardDir);
                            forwardDir.y = 0; 
                            forwardDir.normalize();
                            velocity.add(forwardDir.multiplyScalar(300)); 
                        } else {
                            camOffset.y -= Math.min(fallSpeed / 10, 5.0); 
                        }
                    }
                    velocity.y = 0;
                    body.position.y = groundHeight + standingEyeHeight;
                    canJump = true;
                }

                // --- カメラアニメーションの更新（共通） ---
                let rollOffsetHeight = 0;
                let rollRotationZ = 0;

                if (isRolling) {
                    const elapsed = (time - rollStartTime) / 1000;
                    if (elapsed < rollDuration) {
                        const t = elapsed / rollDuration;
                        const crouchDepth = Math.sin(t * Math.PI) * 8.5; 
                        rollOffsetHeight = -crouchDepth;
                        rollRotationZ = -2 * Math.PI * easeOutCubic(t);
                    } else {
                        isRolling = false;
                    }
                }

                const currentSpeed = Math.sqrt(velocity.x**2 + velocity.z**2);
                if (canJump && !isRolling && currentSpeed > 5) {
                    const frequency = isSprinting ? 16 : 11;
                    walkCycle += delta * frequency;
                    const bobY = Math.sin(walkCycle) * (isSprinting ? 0.6 : 0.3);
                    const bobX = Math.cos(walkCycle * 0.5) * (isSprinting ? 0.5 : 0.3);
                    camOffset.y += (bobY - camOffset.y) * delta * 15;
                    camOffset.x += (bobX - camOffset.x) * delta * 15;
                } else {
                    const breath = Math.sin(time * 0.002) * 0.05;
                    camOffset.y += (breath - camOffset.y) * delta * 5;
                    camOffset.x += (0 - camOffset.x) * delta * 5;
                }

                if (!isRolling) {
                    let tiltTarget = 0;
                    if (moveLeft) tiltTarget = 0.05;
                    if (moveRight) tiltTarget = -0.05; 
                    if (isSprinting) tiltTarget *= 2.0;
                    targetRollAngle += (tiltTarget - targetRollAngle) * delta * 10;
                } else {
                    targetRollAngle = 0;
                }

                // 目の高さにスタンディングハイトを適用
                camera.position.y = standingEyeHeight + camOffset.y + rollOffsetHeight;
                camera.position.x = camOffset.x;
                camera.rotation.z = rollRotationZ + targetRollAngle;
                
                const targetFov = baseFov + (currentSpeed / 70) + (isRolling ? 20 : 0);
                camera.fov += (targetFov - camera.fov) * delta * 5.0;
                camera.updateProjectionMatrix();

                const speedEffect = Math.min((currentSpeed + Math.abs(velocity.y)) / 1000, 0.8);
                speedLines.style.opacity = speedEffect;
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
