<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>遥かなる稜線</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #aaccff; }
        #instructions {
            position: absolute;
            top: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0,0,0,0.3);
            color: white;
            pointer-events: none;
            text-align: center;
            user-select: none;
            backdrop-filter: blur(8px);
        }
        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(20, 10, 40, 0.2);
            z-index: 99;
        }
        h1 { margin: 0; font-size: 50px; text-shadow: 0 0 20px rgba(200,220,255,0.8); font-weight: lighter; letter-spacing: 4px; }
        p { font-size: 18px; line-height: 1.6; text-shadow: 0 0 5px rgba(0,0,50,0.5); }
        .key { font-weight: bold; color: #fff; border: 1px solid #fff; padding: 2px 6px; border-radius: 4px; background: rgba(255,255,255,0.2); }
        #vignette {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, rgba(50,20,80,0.3) 100%);
            pointer-events: none;
            z-index: 90;
        }
        #speed-lines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: transparent;
            opacity: 0;
            pointer-events: none;
            z-index: 91;
            box-shadow: inset 0 0 100px rgba(200,240,255,0.3);
            transition: opacity 0.1s;
        }
    </style>
</head>
<body>
    <div id="vignette"></div>
    <div id="speed-lines"></div>
    <div id="blocker">
        <div id="instructions">
            <h1>遥かなる稜線</h1>
            <p>
                クリックして旅を始める<br><br>
                移動: <span class="key">W, A, S, D</span><br>
                ダッシュ: <span class="key">Shift</span><br>
                ジャンプ: <span class="key">Space</span><br>
                <br>
                <span style="font-size: 14px; color: #ddeeff;">果てしなく続く平原と山脈</span>
            </p>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';
        import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
        import { Sky } from 'three/addons/objects/Sky.js';

        // --- グローバル変数 ---
        let camera, scene, renderer, controls;
        let playerBody; 
        let sky, sun;
        
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let isSprinting = false;
        let canJump = false;

        let prevTime = performance.now();

        // --- アクション・カメラ設定 ---
        let walkCycle = 0;
        const camOffset = { x: 0, y: 0 }; 
        
        let isRolling = false;
        let rollStartTime = 0;
        const rollDuration = 0.65;
        const rollThreshold = 280;
        let targetRollAngle = 0;
        
        const baseFov = 100;
        const standingEyeHeight = 10;
        
        // --- 地形設定 ---
        const chunkSize = 400; 
        const chunkRes = 40; 
        const renderDistance = 3; 
        const waterLevel = 22; 
        const chunks = {};
        const perlin = new ImprovedNoise();
        const seed = Math.random() * 100;

        // --- 盆地生成パラメータ ---
        const BASIN_FLAT_RADIUS = 550;   
        const BASIN_WALL_START = 550;    
        const BASIN_PEAK_DIST = 1100;    
        const BASIN_WALL_END = 1600;     
        const WALL_HEIGHT = 500;         
        
        let treeGeometry, treeMaterial;
        let grassGeometry, grassMaterial;
        let waterGeometry, waterMaterial;

        const speedLines = document.getElementById('speed-lines');

        const skyUniforms = {
            turbidity: 8,
            rayleigh: 2,
            mieCoefficient: 0.005,
            mieDirectionalG: 0.8,
            elevation: 25,
            azimuth: 180,
            exposure: 0.6
        };

        const FOG_COLOR = 0xcce0ff; 

        init();
        animate();

        function init() {
            const blocker = document.getElementById('blocker');
            const instructions = document.getElementById('instructions');

            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(FOG_COLOR, 0.0010); 
            scene.background = new THREE.Color(FOG_COLOR);

            camera = new THREE.PerspectiveCamera(baseFov, window.innerWidth / window.innerHeight, 0.1, 8000);

            playerBody = new THREE.Object3D();
            playerBody.position.set(0, 100, 50); 
            playerBody.add(camera); 
            scene.add(playerBody);

            // --- Sky ---
            sky = new Sky();
            sky.scale.setScalar(450000);
            scene.add(sky);

            sun = new THREE.Vector3();
            
            const effectController = skyUniforms;

            const uniforms = sky.material.uniforms;
            uniforms[ 'turbidity' ].value = effectController.turbidity;
            uniforms[ 'rayleigh' ].value = effectController.rayleigh;
            uniforms[ 'mieCoefficient' ].value = effectController.mieCoefficient;
            uniforms[ 'mieDirectionalG' ].value = effectController.mieDirectionalG;

            const phi = THREE.MathUtils.degToRad( 90 - effectController.elevation );
            const theta = THREE.MathUtils.degToRad( effectController.azimuth );
            sun.setFromSphericalCoords( 1, phi, theta );
            uniforms[ 'sunPosition' ].value.copy( sun );

            // --- Lighting ---
            const dirLight = new THREE.DirectionalLight(0xfffaed, 1.5); 
            dirLight.position.set(sun.x * 1000, sun.y * 1000, sun.z * 1000);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 4096;
            dirLight.shadow.mapSize.height = 4096;
            const d = 2500; 
            dirLight.shadow.camera.left = -d;
            dirLight.shadow.camera.right = d;
            dirLight.shadow.camera.top = d;
            dirLight.shadow.camera.bottom = -d;
            dirLight.shadow.camera.far = 6000;
            dirLight.shadow.bias = -0.0001;
            dirLight.shadow.radius = 2; 
            scene.add(dirLight);
            
            const hemiLight = new THREE.HemisphereLight(0xffeeb1, 0x6655aa, 0.85); 
            hemiLight.position.set(0, 500, 0);
            scene.add(hemiLight);

            // --- Controls ---
            controls = new PointerLockControls(playerBody, document.body);
            controls.minPolarAngle = 0.05; 
            controls.maxPolarAngle = Math.PI - 0.05;

            blocker.addEventListener('click', () => controls.lock());
            controls.addEventListener('lock', () => {
                instructions.style.display = 'none';
                blocker.style.display = 'none';
            });
            controls.addEventListener('unlock', () => {
                blocker.style.display = 'block';
                instructions.style.display = 'flex';
            });

            const onKeyDown = (e) => {
                switch (e.code) {
                    case 'KeyW': moveForward = true; break;
                    case 'KeyA': moveLeft = true; break;
                    case 'KeyS': moveBackward = true; break;
                    case 'KeyD': moveRight = true; break;
                    case 'ShiftLeft': isSprinting = true; break;
                    case 'Space': 
                        if (canJump && !isRolling) {
                            velocity.y += 160; 
                            canJump = false;
                        }
                        break;
                }
            };
            const onKeyUp = (e) => {
                switch (e.code) {
                    case 'KeyW': moveForward = false; break;
                    case 'KeyA': moveLeft = false; break;
                    case 'KeyS': moveBackward = false; break;
                    case 'KeyD': moveRight = false; break;
                    case 'ShiftLeft': isSprinting = false; break;
                }
            };
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            prepareAssets();

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            renderer.toneMapping = THREE.CineonToneMapping; 
            renderer.toneMappingExposure = 0.9; 
            
            document.body.appendChild(renderer.domElement);
            window.addEventListener('resize', onWindowResize);
        }

        function prepareAssets() {
            // 木
            const trunkGeo = new THREE.CylinderGeometry(1, 2.5, 12, 6);
            trunkGeo.translate(0, 6, 0);
            const leavesGeo = new THREE.ConeGeometry(7, 18, 6);
            leavesGeo.translate(0, 20, 0);
            const leavesGeo2 = new THREE.ConeGeometry(5, 14, 6);
            leavesGeo2.translate(0, 28, 0);
            
            treeGeometry = BufferGeometryUtils.mergeGeometries([trunkGeo, leavesGeo, leavesGeo2]);
            treeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x44bb66, 
                flatShading: true, 
                roughness: 0.8,
                emissive: 0x002211,
                emissiveIntensity: 0.2
            });

            // 草
            grassGeometry = new THREE.PlaneGeometry(4, 4);
            grassGeometry.translate(0, 2, 0);
            grassMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x99dd55, 
                side: THREE.DoubleSide, 
                alphaTest: 0.5,
                emissive: 0x113300,
                emissiveIntensity: 0.1
            });

            // 水
            waterGeometry = new THREE.PlaneGeometry(chunkSize, chunkSize);
            waterGeometry.rotateX(-Math.PI / 2);
            waterMaterial = new THREE.MeshStandardMaterial({
                color: 0x22eeff,
                transparent: true,
                opacity: 0.7, 
                roughness: 0.1,
                metalness: 0.3,
                emissive: 0x006688,
                emissiveIntensity: 0.4
            });
        }

        // --- ★地形生成ロジックの修正 ---
        function getNoiseHeight(x, z) {
            const dist = Math.sqrt(x * x + z * z);
            
            // ベース地形（平原のゆらぎ）
            let baseHeight = 0;
            baseHeight += Math.abs(perlin.noise(x * 0.003 + seed, z * 0.003 + seed, seed)) * 30;

            let finalHeight = baseHeight;

            // 盆地（聖域）と外側の処理
            if (dist < BASIN_WALL_END) {
                // --- 内側エリア（変更なし） ---
                if (dist < BASIN_FLAT_RADIUS) {
                    let h = 32 + perlin.noise(x * 0.008, z * 0.008, seed) * 10;
                    const riverNoise = perlin.noise(x * 0.004 + seed, z * 0.004 + seed, seed + 10);
                    if (riverNoise < -0.15) {
                        const depth = (-0.15 - riverNoise) * 60; 
                        h -= depth; 
                    }
                    if (dist < 180) {
                        const lakeDepth = (1.0 - (dist / 180)) * 25;
                        h -= lakeDepth;
                    }
                    finalHeight = h;
                } else {
                    // 崖（外輪山）
                    let wallFactor = 0;
                    if (dist < BASIN_PEAK_DIST) {
                        const t = (dist - BASIN_WALL_START) / (BASIN_PEAK_DIST - BASIN_WALL_START);
                        wallFactor = t * t * (3 - 2 * t);
                    } else {
                        const t = (dist - BASIN_PEAK_DIST) / (BASIN_WALL_END - BASIN_PEAK_DIST);
                        wallFactor = 1 - (t * t * (3 - 2 * t)); 
                    }
                    const mountainNoise = Math.abs(perlin.noise(x * 0.02, z * 0.02, seed + 50)) * 180;
                    const wallHeight = (WALL_HEIGHT + mountainNoise) * wallFactor;
                    finalHeight = baseHeight + wallHeight;
                    if (dist < BASIN_PEAK_DIST && finalHeight < 30) finalHeight = 30; 
                }
            } else {
                // --- ★外側エリアの生成ロジック変更 ---
                
                // 1. 盆地からのブレンド係数
                let blend = (dist - BASIN_WALL_END) / 1500;
                if (blend > 1.0) blend = 1.0;
                blend = blend * blend * (3 - 2 * blend); 

                // 2. バイオーム決定ノイズ (大規模な地域の区分け)
                // 低周波ノイズを使って、「山岳地帯」と「平原・丘陵地帯」を分ける
                // 値が大きい＝山、小さい＝平原・湖
                const biomeNoise = perlin.noise(x * 0.0004, z * 0.0004, seed + 100);
                
                // 山岳地帯の係数（0.3以上で山になり始める、なめらかに補間）
                const mountainMix = THREE.MathUtils.smoothstep(biomeNoise, 0.2, 0.6);

                // --- 山岳バイオーム ---
                const largeMtn = Math.abs(perlin.noise(x * 0.0015, z * 0.0015, seed + 10)) * 1200;
                const detailMtn = perlin.noise(x * 0.01, z * 0.01, seed + 20) * 150;
                const mountainShape = largeMtn + detailMtn;

                // --- 平原・丘陵バイオーム ---
                // なだらかな丘、そして水面(22)より下がる部分を作ることで湖や川にする
                // 基本高さを水面より少し上(40付近)に設定し、ノイズで±50くらい揺らす
                const hillBase = perlin.noise(x * 0.001, z * 0.001, seed + 30) * 60; 
                const hillDetail = perlin.noise(x * 0.005, z * 0.005, seed + 40) * 20;
                
                // 川・谷を削るノイズ (0に近いほど深い谷)
                const riverCarver = Math.abs(perlin.noise(x * 0.0005 + 500, z * 0.0005 + 500, seed + 60));
                let riverDepth = 0;
                if (riverCarver < 0.1) {
                    // 川の深さ
                    riverDepth = (0.1 - riverCarver) * 800; 
                }

                // 平原の基本形状 (水面近く)
                const plainShape = 35 + hillBase + hillDetail - riverDepth;

                // --- バイオームの合成 ---
                // 山と平原を混ぜる
                let outerTerrain = (mountainShape * mountainMix) + (plainShape * (1 - mountainMix));

                // 盆地との接続（ブレンド）
                // 盆地の外側すぐは平原から始めたいので、blendを考慮
                // baseHeight(0付近) + 生成地形
                finalHeight = baseHeight + (outerTerrain * blend);

                // 注: ここで seaLevel 以下にならないような clamp 処理は削除し、湖ができるようにする
            }
            
            return finalHeight; 
        }

        function getSlope(x, z) {
            const step = 2;
            const h = getNoiseHeight(x, z);
            const hx = getNoiseHeight(x + step, z);
            const hz = getNoiseHeight(x, z + step);
            const dx = (hx - h) / step;
            const dz = (hz - h) / step;
            return Math.sqrt(dx*dx + dz*dz);
        }

        function updateChunks() {
            const playerPos = playerBody.position;
            const cx = Math.floor(playerPos.x / chunkSize);
            const cz = Math.floor(playerPos.z / chunkSize);
            const activeKeys = new Set();

            for (let x = -renderDistance; x <= renderDistance; x++) {
                for (let z = -renderDistance; z <= renderDistance; z++) {
                    const key = `${cx + x},${cz + z}`;
                    activeKeys.add(key);
                    if (!chunks[key]) createChunk(cx + x, cz + z);
                }
            }
            for (const key in chunks) {
                if (!activeKeys.has(key)) {
                    scene.remove(chunks[key]);
                    delete chunks[key];
                }
            }
        }

        function createChunk(cx, cz) {
            const group = new THREE.Group();
            
            const geometry = new THREE.PlaneGeometry(chunkSize, chunkSize, chunkRes, chunkRes);
            geometry.rotateX(-Math.PI / 2);
            const posAttr = geometry.attributes.position;
            const colors = [];

            for (let i = 0; i < posAttr.count; i++) {
                const x = posAttr.getX(i) + (cx * chunkSize);
                const z = posAttr.getZ(i) + (cz * chunkSize);
                const y = getNoiseHeight(x, z);
                posAttr.setY(i, y);

                // 色付けロジック
                if (y < waterLevel + 3) {
                    // 砂浜・川岸
                    colors.push(0.85, 0.8, 0.65);
                } else if (y < 120) {
                    // 緑の草原エリア（以前より範囲を拡大）
                    const n = perlin.noise(x*0.02, z*0.02, seed);
                    const r = 0.35 + n * 0.1;
                    const g = 0.7 + n * 0.15;
                    const b = 0.3 + n * 0.1;
                    colors.push(r, g, b); 
                } else if (y < 400) { 
                    // 岩肌
                    colors.push(0.6, 0.55, 0.5); 
                } else { 
                    // 雪山
                    colors.push(0.96, 0.98, 1.0); 
                }
            }
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.computeVertexNormals();
            
            const terrainMesh = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({ 
                vertexColors: true, 
                flatShading: true, 
                roughness: 1.0 
            }));
            terrainMesh.position.set(cx * chunkSize, 0, cz * chunkSize);
            terrainMesh.receiveShadow = true;
            group.add(terrainMesh);

            // 水面（エリア制限を撤廃し、全チャンクに生成）
            const waterMesh = new THREE.Mesh(waterGeometry, waterMaterial);
            waterMesh.position.set(cx * chunkSize, waterLevel, cz * chunkSize);
            group.add(waterMesh);

            const treeCount = 60; // 木の密度を少し上げる
            const treeMesh = new THREE.InstancedMesh(treeGeometry, treeMaterial, treeCount);
            treeMesh.castShadow = true;
            treeMesh.receiveShadow = true;
            
            const dummy = new THREE.Object3D();
            let tIdx = 0;
            
            for (let i = 0; i < treeCount; i++) {
                const rx = (Math.random() - 0.5) * chunkSize;
                const rz = (Math.random() - 0.5) * chunkSize;
                const wx = rx + (cx * chunkSize);
                const wz = rz + (cz * chunkSize);
                
                const h = getNoiseHeight(wx, wz);
                const slope = getSlope(wx, wz);
                
                // 水中には木を生やさない (waterLevel + 4)
                if (h > waterLevel + 4 && slope < 1.2) {
                    // 高度制限: 平地や低い丘に木を集中させる
                    if (h < 250) {
                        // ランダム配置
                        if (Math.random() > 0.4) {
                            dummy.position.set(rx, h, rz);
                            const s = 0.8 + Math.random() * 1.0; 
                            dummy.scale.set(s, s, s);
                            dummy.rotation.y = Math.random() * Math.PI * 2;
                            dummy.updateMatrix();
                            treeMesh.setMatrixAt(tIdx++, dummy.matrix);
                        }
                    }
                }
            }
            treeMesh.count = tIdx; 
            treeMesh.position.set(cx * chunkSize, 0, cz * chunkSize);
            group.add(treeMesh);

            const grassCount = 1200;
            const grassMesh = new THREE.InstancedMesh(grassGeometry, grassMaterial, grassCount);
            let gIdx = 0;
            for (let i = 0; i < grassCount; i++) {
                const rx = (Math.random() - 0.5) * chunkSize;
                const rz = (Math.random() - 0.5) * chunkSize;
                const wx = rx + (cx * chunkSize);
                const wz = rz + (cz * chunkSize);
                const h = getNoiseHeight(wx, wz);
                const slope = getSlope(wx, wz);

                if (h > waterLevel + 2 && h < 250 && slope < 0.8) {
                    dummy.position.set(rx, h, rz);
                    dummy.scale.set(1, 1, 1);
                    dummy.rotation.set(0, Math.random() * Math.PI, 0);
                    dummy.updateMatrix();
                    grassMesh.setMatrixAt(gIdx++, dummy.matrix);
                }
            }
            grassMesh.count = gIdx;
            grassMesh.position.set(cx * chunkSize, 0, cz * chunkSize);
            group.add(grassMesh);

            scene.add(group);
            chunks[`${cx},${cz}`] = group;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function easeOutCubic(x) {
            return 1 - Math.pow(1 - x, 3);
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = Math.min((time - prevTime) / 1000, 0.1); 
            prevTime = time;

            if (sky) {
                const uniforms = sky.material.uniforms;
                const tempVec = new THREE.Vector3().copy(uniforms['sunPosition'].value).normalize();
                const dirLight = scene.children.find(c => c.isDirectionalLight);
                if (dirLight) {
                    dirLight.position.copy(tempVec).multiplyScalar(10000);
                }
            }

            if (controls.isLocked) {
                updateChunks();

                const body = playerBody;

                const dampingX = canJump ? 8.0 : 1.0; 
                const dampingZ = canJump ? 8.0 : 1.0;
                
                velocity.x -= velocity.x * dampingX * delta;
                velocity.z -= velocity.z * dampingZ * delta;
                velocity.y -= 9.8 * 60.0 * delta; 

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                const speedBase = isSprinting ? 1200.0 : 600.0;
                
                if (!isRolling) {
                    if (moveForward || moveBackward) velocity.z -= direction.z * speedBase * delta;
                    if (moveLeft || moveRight) velocity.x -= direction.x * speedBase * delta;
                }

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                body.position.y += (velocity.y * delta); 

                const groundHeight = getNoiseHeight(body.position.x, body.position.z);
                
                if (body.position.y < groundHeight + standingEyeHeight) {
                    if (!canJump) { 
                        const fallSpeed = Math.abs(velocity.y);
                        if (fallSpeed > rollThreshold) {
                            isRolling = true;
                            rollStartTime = time;
                            const forwardDir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.getWorldQuaternion(new THREE.Quaternion()));
                            forwardDir.y = 0; forwardDir.normalize();
                            velocity.add(forwardDir.multiplyScalar(300)); 
                        } else {
                            camOffset.y -= Math.min(fallSpeed / 10, 5.0); 
                        }
                    }
                    velocity.y = 0;
                    body.position.y = groundHeight + standingEyeHeight;
                    canJump = true;
                }

                let rollOffsetHeight = 0;
                let rollRotationZ = 0;

                if (isRolling) {
                    const elapsed = (time - rollStartTime) / 1000;
                    if (elapsed < rollDuration) {
                        const t = elapsed / rollDuration;
                        const crouchDepth = Math.sin(t * Math.PI) * 8.5; 
                        rollOffsetHeight = -crouchDepth;
                        rollRotationZ = -2 * Math.PI * easeOutCubic(t);
                    } else {
                        isRolling = false;
                    }
                }

                const currentSpeed = Math.sqrt(velocity.x**2 + velocity.z**2);
                if (canJump && !isRolling && currentSpeed > 5) {
                    const frequency = isSprinting ? 16 : 11;
                    walkCycle += delta * frequency;
                    const bobY = Math.sin(walkCycle) * (isSprinting ? 0.6 : 0.3);
                    const bobX = Math.cos(walkCycle * 0.5) * (isSprinting ? 0.5 : 0.3);
                    camOffset.y += (bobY - camOffset.y) * delta * 15;
                    camOffset.x += (bobX - camOffset.x) * delta * 15;
                } else {
                    const breath = Math.sin(time * 0.002) * 0.05;
                    camOffset.y += (breath - camOffset.y) * delta * 5;
                    camOffset.x += (0 - camOffset.x) * delta * 5;
                }

                if (!isRolling) {
                    let tiltTarget = 0;
                    if (moveLeft) tiltTarget = 0.05;
                    if (moveRight) tiltTarget = -0.05; 
                    if (isSprinting) tiltTarget *= 2.0;
                    targetRollAngle += (tiltTarget - targetRollAngle) * delta * 10;
                } else {
                    targetRollAngle = 0;
                }

                camera.position.y = camOffset.y + rollOffsetHeight;
                camera.position.x = camOffset.x;
                camera.rotation.z = rollRotationZ + targetRollAngle;
                
                const targetFov = baseFov + (currentSpeed / 70) + (isRolling ? 20 : 0);
                camera.fov += (targetFov - camera.fov) * delta * 5.0;
                camera.updateProjectionMatrix();

                const speedEffect = Math.min((currentSpeed + Math.abs(velocity.y)) / 1000, 0.8);
                speedLines.style.opacity = speedEffect;
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
